# 第一题

为什么会提示错误，应该如何解决上述问题？

```javascript
type User = {
  id: number;
  kind: string;
};

function makeCustomer<T extends User>(u: T): T {
  // Error（TS 编译器版本：v4.4.2）
  // Type '{ id: number; kind: string; }' is not assignable to type 'T'.
  // '{ id: number; kind: string; }' is assignable to the constraint of type 'T', 
  // but 'T' could be instantiated with a different subtype of constraint 'User'.
  return {
    id: u.id,
    kind: 'customer'
  }
}
```


# 第二题

怎么能满足需求

``` javascript
function f(a: string | number, b: string | number) {
  if (typeof a === 'string') {
    return a + ':' + b; // no error but b can be number!
  } else {
    return a + b; // error as b can be number | string
  }
}

f(2, 3); // Ok
f(1, 'a'); // Error
f('a', 2); // Error
f('a', 'b') // Ok
```


# 第一题答案
``` javascript
// 答案
T extends User 的意思 约束泛型T 符合 User结构，但不局限于这个结构。
如果我makeCustomer({
id: 1,
kind: '2',
age: 30
});

那么泛型T自动推导为
{
id: number;
kind: string;
age: number
}
这样就满足了User的约束 可以入参。但是返回的类型也限定成了这个结构。
那么例子中 的返回
return {
id: u.id,
kind: 'customer'
}
就不满足于{
id: number;
kind: string;
age: number
}
因为少了一个age。
```


# 第二题答案

``` javascript
function f<T extends string | number>(a: T, b: T) {
  if (typeof a === 'string') {
    return a + ':' + b; // no error but b can be number!
  } else {
    return (a as number) + (b as number); // error as b can be number | string
  }
}

f(2, 3); // Ok
f(1, 'a'); // Error
f('a', 2); // Error
f(2, 2) // Ok
```