# ES6 的数据类型

基本类型

- Boolean
- Number
- String
- Symbol
- undefined
- null

引用类型

- Function
- Array
- Object

# Typescript 的数据类型

基本类型

- Boolean
- Number
- String
- Symbol
- undefined
- null

引用类型

- Function
- Array
- Object

新增类型

- void
- any
- never
- 元组
- 枚举
- 高级类型（高级玩法）

# 类型注解

作用：相当于强类型中的类型声明，对变量起到约束作用

语法：（变量/函数）：type

# 原始类型

```javascript
let bool: boolean = true;
let num: number | undefined | null = 123;
let str: string = "abc";
str = 123; // 报错，变量的数据类型是不可以互相赋值改变的
```

# 数组

```javascript
// 这个数组只能是number类型
let arr1: number[] = [1, 2, 3];
// 这个数组可以是number、string，｜ 是联合类型
let arr2: Array<number | string> = [1, 2, 3, "4"]; // Array 是ts为我们预留的范型接口
```

# 元组

特殊的数组，限定了数组的类型和个数

```javascript
let tuple: [number, string] = [0, "1"];
// 下面是元组的越界问题：实际开发中不建议使用
// tuple.push(2) 可以push
// console.log(tuple)
// tuple[2] 不能越界访问
```

# 函数

```javascript
// (x: number, y: number): number => x + y 通常返回值类型是不需要写的，利用了ts的类型推断功能
let add = (x: number, y: number) => x + y;
let compute: (x: number, y: number) => number; // 定义了一个函数类型，但是没有具体的实现
compute = (a, b) => a + b; // 实现上面的函数类型
```

# 对象

```javascript
let obj: { x: number, y: number } = { x: 1, y: 2 };
obj.x = 3;
```

# symbol

```javascript
let s1: symbol = Symbol();
let s2 = Symbol();
// console.log(s1 === s2) false
```

# undefined, null

不可以赋值给其它类型，但其它类型可以赋值为 undefined、null

tsconfig.json 中的 "strictNullChecks": false, 上面后面才成立（需要使用联合类型）

```javascript
let un: undefined = undefined;
let nu: null = null;
num = undefined;
num = null;
```

# void

```javascript
let noReturn = () => {}; // 没有任何返回值的函数
```

# any

跟 js 没什么区别了，不建议使用

```javascript
let x;
x = 1;
x = [];
x = () => {};
```

# never

永远不会有返回值的类型

```javascript
let error = () => {
  throw new Error("error");
};
let endless = () => {
  while (true) {}
};
```

TODO：never 和 void 的区别

# 枚举类型

方法：将程序中不容易记忆的硬编码，或者是在未来中可能改变的常量，抽取出来，定义成枚举类型，这样可以提高程序的可读性和可维护性，枚举类型可以使程序不变应万变

```javascript
// 角色判断例子
function initByRole(role) {
  if (role === 1 || role === 2) {
    // do sh
  } else if (role === 3) {
    // do sh
  } else {
    // do sh
  }
}
```

上面代码的问题：

1. 可读性差：很难记住数字的含义
2. 可维护差：硬编码，牵一发动全身

解决办法：使用 ts 的枚举类型，把没有意义的数字赋值为有意义的枚举

``` javascript
const enum Role {
  xiaoming,
  xiaoli,
  role
}

function initByRole(role) {
  if (role: Role.xiaoming === 1 || role: Role.xiaoli === 2) {
    // do sh
  } else if (role: Role.root === 3) {
    // do sh
  } else {
    // do sh
  }
}
```

# 什么是枚举

一组有名字的常量集合（比如：手机里的通讯录）

# 枚举类型

1. 数字枚举

```javascript
// 如果不写1，默认是从0开始,有反向映射
enum Role {
  Reporter = 1,
  Developer,
  Maintainer,
  Owner,
  Guest
}
```

2. 字符串枚举

```javascript
// 这里没有反向映射
enum Message {
  Success = '恭喜你，成功了',
  Fail = '抱歉，失败了'
}
```

3. 异构枚举 -- 容易混淆，不建议使用

``` javascript
// 数字和字符串一起使用就叫 -- 异构枚举
enum Answer {
  N,
  Y = 'Yes'
}
```

4. 枚举成员

``` javascript
// Role.Reporter = 0  枚举成员的值是只读类型不能修改
enum Char {
  // const member 常量枚举，编辑的时候计算出结果，运行时直接使用
  a,
  b = Char.a,
  c = 1 + 3,
  // computed member
  d = Math.random(),
  e = '123'.length,
  f = 4
}
```

5. 常量枚举

``` javascript
// 用const生命的就是一个常量枚举，编译的时候会被移除，有利于减少编译代码
// 作用：当我们不需要一个对象，需要一个值的时候，
const enum Month {
    Jan,
    Feb,
    Mar,
    Apr = Month.Mar + 1,
    // May = () => 5
}
let month = [Month.Jan, Month.Feb, Month.Mar]
```

6. 枚举类型

``` javascript
enum E { a, b }
enum F { a = 0, b = 1 }
enum G { a = 'apple', b = 'banana' }

let e: E = 3
let f: F = 3
// console.log(e === f)

let e1: E.a = 3
let e2: E.b = 3
let e3: E.a = 3
// console.log(e1 === e2)
// console.log(e1 === e3)

let g1: G = G.a
let g2: G.a = G.a

```