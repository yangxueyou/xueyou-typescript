# ES6 的数据类型

基本类型

- Boolean
- Number
- String
- Symbol
- undefined
- null

引用类型

- Function
- Array
- Object

# Typescript 的数据类型

基本类型

- Boolean
- Number
- String
- Symbol
- undefined
- null

引用类型

- Function
- Array
- Object

新增类型

- void
- any
- Unknown
- never
- 元组
- 枚举
- 高级类型（高级玩法）

# 类型注解

作用：相当于强类型中的类型声明，对变量起到约束作用

语法：（变量/函数）：type

# 原始类型

```javascript
let bool: boolean = true;
let num: number | undefined | null = 123;
let str: string = "abc";
str = 123; // 报错，变量的数据类型是不可以互相赋值改变的
```

# 数组

```javascript
// 这个数组只能是number类型
let arr1: number[] = [1, 2, 3];
// 这个数组可以是number、string，｜ 是联合类型
let arr2: Array<number | string> = [1, 2, 3, "4"]; // Array 是ts为我们预留的范型接口
```

# 元组

特殊的数组，限定了数组的类型和个数

```javascript
let tuple: [number, string] = [0, "1"];
// 下面是元组的越界问题：实际开发中不建议使用
// tuple.push(2) 可以push
// console.log(tuple)
// tuple[2] 不能越界访问
```

# 函数

```javascript
// (x: number, y: number): number => x + y 通常返回值类型是不需要写的，利用了ts的类型推断功能
let add = (x: number, y: number) => x + y;
let compute: (x: number, y: number) => number; // 定义了一个函数类型，但是没有具体的实现
compute = (a, b) => a + b; // 实现上面的函数类型
```

# 对象

```javascript
let obj: { x: number, y: number } = { x: 1, y: 2 };
obj.x = 3;
```

# symbol

```javascript
let s1: symbol = Symbol();
let s2 = Symbol();
// console.log(s1 === s2) false
```

# undefined, null

不可以赋值给其它类型，但其它类型可以赋值为 undefined、null

tsconfig.json 中的 "strictNullChecks": false, 上面后面才成立（需要使用联合类型）

```javascript
let un: undefined = undefined;
let nu: null = null;
num = undefined;
num = null;
```


# any

跟 js 没什么区别了，不建议使用

```javascript
let x;
x = 1;
x = [];
x = () => {};
```


# Unknown 类型

就像所有类型都可以赋值给 `any`，所有类型也都可以赋值给 `unknown`。这使得 `unknown` 成为 TypeScript 类型系统的另一种顶级类型（另一种是 `any`）

``` javascript
let value: unknown;

value = true; // OK
value = 42; // OK
value = "Hello World"; // OK
value = []; // OK
value = {}; // OK
value = Math.random; // OK
value = null; // OK
value = undefined; // OK
value = new TypeError(); // OK
value = Symbol("type"); // OK
```

``` javascript
let value: unknown;

let value1: unknown = value; // OK
let value2: any = value; // OK
let value3: boolean = value; // Error
let value4: number = value; // Error
let value5: string = value; // Error
let value6: object = value; // Error
let value7: any[] = value; // Error
let value8: Function = value; // Error
```
`unknown` 类型只能被赋值给 `any` 类型和 `unknown` 类型本身。
直观地说，这是有道理的：只有能够保存任意类型值的容器才能保存 unknown 类型的值。毕竟我们不知道变量 value 中存储了什么类型的值。

``` javascript
let value: unknown;

value.foo.bar; // Error
value.trim(); // Error
value(); // Error
new value(); // Error
value[0][1]; // Error
```

将 value 变量类型设置为 unknown 后，这些操作都不再被认为是类型正确的。通过将 any 类型改变为 unknown 类型，我们已将允许所有更改的默认设置，更改为禁止任何更改。



# void

```javascript
let noReturn = () => {}; // 没有任何返回值的函数

// 声明函数返回值为void，正常不用写返回值，用ts的自动推断就可以了
function warnUser(): void {
  console.log("This is my warning message");
}

```


# never

永远不会有返回值的类型

```javascript
let error = () => {
  throw new Error("error");
};
let endless = () => {
  while (true) {}
};
```

never 和 void 的区别： 在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查，具体示例如下：

``` javascript
type Foo = string | number;

function controlFlowAnalysisWithNever(foo: Foo) {
  if (typeof foo === "string") {
    // 这里 foo 被收窄为 string 类型
  } else if (typeof foo === "number") {
    // 这里 foo 被收窄为 number 类型
  } else {
    // foo 在这里是 never
    const check: never = foo;
  }
}
```

注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型：

``` javascript
type Foo = string | number | boolean;
```

然而他忘记同时修改 controlFlowAnalysisWithNever 方法中的控制流程，这时候 else 分支的 foo 类型会被收窄为 boolean 类型，导致无法赋值给 never 类型，这时就会产生一个编译错误。通过这个方式，我们可以确保

controlFlowAnalysisWithNever 方法总是穷尽了 Foo 的所有可能类型。 通过这个示例，我们可以得出一个结论：`使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。`

# 枚举类型

方法：将程序中不容易记忆的硬编码，或者是在未来中可能改变的常量，抽取出来，定义成枚举类型，这样可以提高程序的可读性和可维护性，枚举类型可以使程序不变应万变

```javascript
// 角色判断例子
function initByRole(role) {
  if (role === 1 || role === 2) {
    // do sh
  } else if (role === 3) {
    // do sh
  } else {
    // do sh
  }
}
```

上面代码的问题：

1. 可读性差：很难记住数字的含义
2. 可维护差：硬编码，牵一发动全身

解决办法：使用 ts 的枚举类型，把没有意义的数字赋值为有意义的枚举

``` javascript
const enum Role {
  xiaoming,
  xiaoli,
  role
}

function initByRole(role) {
  if (role: Role.xiaoming === 1 || role: Role.xiaoli === 2) {
    // do sh
  } else if (role: Role.root === 3) {
    // do sh
  } else {
    // do sh
  }
}
```

# 什么是枚举

一组有名字的常量集合（比如：手机里的通讯录）

# 枚举类型

1. 数字枚举

```javascript
// 如果不写1，默认是从0开始,有反向映射
enum Role {
  Reporter = 1,
  Developer,
  Maintainer,
  Owner,
  Guest
}

// 编译解雇如下
"use strict";
var Direction;
(function (Direction) {
  Direction[(Direction["NORTH"] = 0)] = "NORTH";
  Direction[(Direction["SOUTH"] = 1)] = "SOUTH";
  Direction[(Direction["EAST"] = 2)] = "EAST";
  Direction[(Direction["WEST"] = 3)] = "WEST";
})(Direction || (Direction = {}));
var dir = Direction.NORTH;
```

2. 字符串枚举

```javascript
// 这里没有反向映射
enum Message {
  Success = '恭喜你，成功了',
  Fail = '抱歉，失败了'
}


// 编译结果如下
"use strict";
var Direction;
(function (Direction) {
    Direction["NORTH"] = "NORTH";
    Direction["SOUTH"] = "SOUTH";
    Direction["EAST"] = "EAST";
    Direction["WEST"] = "WEST";
})(Direction || (Direction = {}));
```

3. 异构枚举 -- 容易混淆，不建议使用

``` javascript
// 数字和字符串一起使用就叫 -- 异构枚举
enum Answer {
  N,
  Y = 'Yes'
}
```

4. 枚举成员

``` javascript
// Role.Reporter = 0  枚举成员的值是只读类型不能修改
enum Char {
  // const member 常量枚举，编辑的时候计算出结果，运行时直接使用
  a,
  b = Char.a,
  c = 1 + 3,
  // computed member
  d = Math.random(),
  e = '123'.length,
  f = 4
}
```

5. 常量枚举

``` javascript
// 用const生命的就是一个常量枚举，编译的时候会被移除，有利于减少编译代码
// 作用：当我们不需要一个对象，需要一个值的时候，
const enum Month {
    Jan,
    Feb,
    Mar,
    Apr = Month.Mar + 1,
    // May = () => 5
}
let month = [Month.Jan, Month.Feb, Month.Mar]

// 常量枚举编译结果如下
"use strict";
var dir = 0 /* NORTH */;
```

6. 枚举类型

``` javascript
enum E { a, b }
enum F { a = 0, b = 1 }
enum G { a = 'apple', b = 'banana' }

let e: E = 3
let f: F = 3
// console.log(e === f)

let e1: E.a = 3
let e2: E.b = 3
let e3: E.a = 3
// console.log(e1 === e2)
// console.log(e1 === e3)

let g1: G = G.a
let g2: G.a = G.a

```