# 介绍

ts编译器在做类型检查时，所秉承的一些原则，以及表现出的一些行为

作用：辅助开发，提高开发效率

- 类型推断
- 类型兼容性
- 类型保护

# 类型推断

有时候`不需要指定变量的类型（函数返回值的类型）`，ts可以根据某些规则自动的为其推断出一个类型

- 基础类型推断
- 最佳通用类型推断
- 上下文类型推断


# 基础类型推断

``` javascript
// 这些都是从右到左的推断，我们就不需要写类型了
let a = 1;
let b = [1, null, 'a']
let c = {x: 1, y: 'a'}

let d = (x = 1) => x + 1
```

# 上下文类型推断

``` javascript
// 根据左侧的事件绑定，推断出右侧参数的类型，不需要写类型了
window.onkeydown = (event) => {
    // console.log(event.button)  // button不是一个键盘事件的属性，会报错，它是一个鼠标事件的属性
}
```

# 类型断言

有的时候ts的推断不符合我们的预期，我们可以覆盖ts自动的推论 -- 类型断言

类型断言可以增加我们代码的灵活性，在改造一些就代码非常有效，要注意避免滥用，要对上下文有充足的预判，没有任何根据的类型断言，会给代码带来安全隐患

``` javascript
interface Foo {
    bar: number
}
// let foo = {} as Foo  // 类型断言，但是下面没有加bar属性，或者忘了，也不会报错，给我们代码带来一些安全隐患
// let foo = <Foo>{}
let foo: Foo = {
    bar: 1
}
// foo.bar = 1
```

# 类型兼容性

当一个类型Y可以被赋值给另一个类型X时，我们就可以说类型X兼容类型Y

X兼容Y：X（目标类型）= Y（源类型）

``` javascript 
"strictNullChecks": false,   // tsconfig.json，这样字符串就可以复制给一个null的

/*
 * X（目标类型） = Y（源类型），X 兼容 Y
 */

let s: string = 'a'
str = null

// 字符型是兼容null类型的，null是string的子类型
```

Q：为什么要讨论类型兼容性问题？

A：ts允许我们把类型不同的变量相互赋值，可能会产生不可靠的行为，但确增加了语言的灵活性

A：类型兼容性的例子广泛存在于：接口、函数、类

# 接口兼容性

``` javascript
interface X {
    a: any;
    b: any;
}
interface Y {
    a: any;
    b: any;
    c: any;
}
let x: X = {a: 1, b: 2}
let y: Y = {a: 1, b: 2, c: 3}
x = y // 是因为y接口有x所有的属性，成员少的兼容成员多的
// y = x
```

# 函数兼容性