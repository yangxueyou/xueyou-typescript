# 1.简介

ts 为了保证语言的灵活性，所引用的一些语言特性，这些特性有助于我们应对复杂的开发场景

# 2.交叉类型

将多个类型合并成一个类型，新的类型将具有所有类型的特性，适合 `对象混入的场景` -- 交叉类型取并集

```javascript
interface DogInterface {
  run(): void;
}
interface CatInterface {
  jump(): void;
}
// 交叉类型用 & 连接，pet具有两个接口的方法
let pet: DogInterface & CatInterface = {
  run() {},
  jump() {},
};
```

# 3. 联合类型

声明的类型并不确定，可以为多个类型中的一个 -- 联合类型取交集

```javascript
let a: number | string = "";
```

```javascript
// 这也是联合类型，取交集
class Dog implements DogInterface {
    run() {}
    eat() {}
}
class Cat  implements CatInterface {
    jump() {}
    eat() {}
}
enum Master { Boy, Girl }
function getPet(master: Master) {
    let pet = master === Master.Boy ? new Dog() : new Cat();
    // pet.run()    // 取交集，所以这报错
    // pet.jump()   // 取交集，所以这报错，解决办法看下面代码，或者类型保护那块
    pet.eat()
    return pet
}
```

```javascript
interface Square {
  kind: "square"; // 通过两个接口共有属性kind，就可以创建不同的保护区块
  size: number;
}
interface Rectangle {
  kind: "rectangle";
  width: number;
  height: number;
}
interface Circle {
  kind: "circle";
  radius: number;
}
type Shape = Square | Rectangle | Circle;
function area(s: Shape) {
  switch (s.kind) {
    case "square":
      return s.size * s.size;
    case "rectangle":
      return s.height * s.width;
    case "circle":
      return Math.PI * s.radius ** 2;
    default:
      return ((e: never) => {
        throw new Error(e);
      })(s);  // 如果新家一个属性，但是case忘加了，这个时候ts类型检查就会报错了，有助于发现错误
  }
}
console.log(area({kind: 'circle', radius: 1}))
```

# 4. 字面量类型

有的时候我们需要同时限定变量的`类型`和`取值`

```javascript
let b: "a" | "b" | "c"; // 只能在abc中取值 -- 字符串字面量联合类型

let c: 1 | 2 | 3; // 数字字面量联合类型
```


# 5. 索引类型

结论：索引类型，可以实现对对象属性的“查询”和“访问”，然后配合泛型约束，就能使我们建立对对象，对象属性以及属性值之间的约束关系

``` javascript
let obj = {
    a: 1,
    b: 2,
    c: 3
}
// 获取obj对应属性的值，放到数组中
function getValues(obj: any, keys: string[]) {
    return keys.map(key => obj[key])
}

console.log(getValues(obj, ['a', 'b']))
console.log(getValues(obj, ['d', 'e']))   // 没有这个key，也不到错，解决办法 -- ts的索引类型


// 约束：keys里面的元素一定是obj的属性
// T约束obj，K约束keys数组
// K增加类型约束 extends，让他继承obj所有属性的联合类型
// 函数的返回值，1.数组；2. 数组元素类型就是属性K对应的类型
// 这样就改造完了，getValues(obj, ['d', 'e'])，传入的属性不在obj中就会报错
// 结论：
function getValues<T, K extends keyof T>(obj: T, keys: K[]): T[K][] {
    return keys.map(key => obj[key])
}
```

``` javascript
// 索引类型的查询操作符 -- keyof T === 类型T所有公共属性的字面量的联合类型
interface Obj {
    a: number;
    b: string;
}
let key: keyof Obj  // 这个时候 key 的类型就变成了，a b 的字面量的联合类型
```

``` javascript
// 索引访问操作符 -- T[K]  == 类型为：对象T属性K所对应的值
let value: Obj['a']   // value的类型就是number类型
```

``` javascript
// 泛型约束 -- T extends U  == 泛型变量可以通过继承某个类型，或者某些属性
```


# 映射类型

通过映射类型，我们可以从一个旧的类型生成一个新的类型

比如：把一个类型中的所有属性，变成只读

本质：预先定义的泛型接口，通常还会结合索引类型，获取对象的属性和属性值，从而将一个对象映射成我们想要的结构

``` javascript
interface Obj {
    a: string;
    b: number;
}
// type 定义一个类型别名，Readonly 是 ts 内置的一个接口
type ReadonlyObj = Readonly<Obj>  
// 把所有接口都变成可选的，可选就是 ？
type PartialObj = Partial<Obj>
// 抽取obj中的一些子集
type PickObj = Pick<Obj, 'a' | 'b'>
// 上面不会创建新的属性，叫 同态
// 下面会创建新的属性，非同态类型
type RecordObj = Record<'x' | 'y', Obj>
```

# 条件类型

由条件表达式决定的类型

T extends U ? X : Y  -- 如果类型 T，可以被复制给类型 U ，那么结果类型就是 X 类型，否则就是 Y 类型

条件类型使类型具有了不唯一性，同样增加了语言的灵活性

``` javascript
// TypeName 就是条件类型，而且是条件类型的嵌套
type TypeName<T> =
    T extends string ? "string" :
    T extends number ? "number" :
    T extends boolean ? "boolean" :
    T extends undefined ? "undefined" :
    T extends Function ? "function" :
    "object";

type T1 = TypeName<string>    // T1 根据上面的逻辑就是 string 字面量类型
```

分布式条件类型：T 如果是一个联合类型的情况下，结果变成多个条件结果的联合类型

``` javascript
// (A | B) extends U ? X : Y
// (A extends U ? X : Y) | (B extends U ? X : Y)
type T3 = TypeName<string | string[]>   // T3 就是 type T3 = "string" | "object"
```

利用这个特性可以实现 -- 类型的过滤

``` javascript
type Diff<T, U> = T extends U ? never : T
type T4 = Diff<"a" | "b" | "c", "a" | "e">    // type T4 = "b" | "c"
// 下面是解释
// Diff<"a", "a" | "e"> | Diff<"b", "a" | "e"> | Diff<"c", "a" | "e">
// never | "b" | "c"
// "b" | "c"

// 过滤 null undefined
type NotNull<T> = Diff<T, null | undefined>
type T5 = NotNull<string | number | undefined | null>

// 上面两个过滤的内置实现
Exclude<T, U>    // 过滤掉 U 中没有的类型
NonNullable<T>    // 过滤掉 null undefined


// Extract<T, U>
type T6 = Extract<"a" | "b" | "c", "a" | "e">   // a，抽取 U 中有的类型


// ReturnType<T>  获取一个函数返回值的类型
type T8 = ReturnType<() => string>    // "string"
```
