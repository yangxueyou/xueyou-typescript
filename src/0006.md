# 理解

把泛型变量与函数参数等同对待，它只不过是另一个纬度的参数，是代表类型而不是值的参数，泛型在高级类型中有广泛的应用

# 泛型函数与泛型接口

很多时候我们希望一个函数或者一个类，可以支持多种数据类型，有很大的灵活性

``` javascript
// 一个打印函数
function log(value: string): string {
  console.log(value);
  return value
}
```


# 什么是泛型

不预先确定的数据类型，具体的类型在使用的时候才能确定

``` javascript
// T 运行的时候才知道类型，另一方面保证了输入和输出是一致的
function log<T>(value: T): T {
    console.log(value);
    return value;
}
log<string[]>(['a', ',b', 'c'])
log(['a', ',b', 'c']) // 推荐这种方式
```

不仅可以用泛型定义一个函数，也可以定义一个函数类型

``` javascript
type Log = <T>(value: T) => T
let myLog: Log = log  // log 是上面的，这个就是泛型函数的实现
```

泛型同样可以用于接口中

```javascript
// 完全等价于上面的类型别名
interface Log {
  <T>(value: T): T // 这里泛型仅仅约束了一个函数，我们也可以用泛型约束其它成员
}
```

``` javascript
// 约定了整个接口，这样我们调用的时候，就需要指定类型
// 指定了string默认类型，就不是必须调用的时候传入一个类型了
interface Log<T = string> {
    (value: T): T
}
let myLog: Log<number> = log
myLog(1)

let myLog: Log = log
myLog('1')
```


# 泛型类

```javascript
// T放在名称后面,这样就可以约束类的成员了
// 泛型不能应用于类的静态成员，如果run方法前面加上静态方法 static，就会报错
class Log<T> {
  run(value: T) {
    console.log(value)
    return value
  }
}
let log1 = new Log<number>()  // 指定参数了，调用的时候就只能传入number类型了
log1.run(1)
let log2 = new Log()  // 如果不指定类型，就可以传如任意类型了
log2.run({ a: 1 })
```


# 泛型约束

``` javascript
function logAdvance<T>(value: T): T {
  console.log(value, value.length); // value.length，这个时候会报错，需要用到泛型约束
  return value;
}
```

``` javascript
// 解决上面的问题
interface Length {
    length: number
}
function logAdvance<T extends Length>(value: T): T {
  console.log(value, value.length);
  return value;
}
// 被约束之后，我们传入的值必须有length属性
logAdvance([1])
logAdvance('123')
logAdvance({ length: 3 })
```

# 泛型的好处

1. 函数和类可以轻松的支持多种类型，增强程序的扩展性

2. 不必写多条函数重载，冗长的联合类型声明，增强代码的可读性

3. 灵活控制类型之间的约束，有了泛型，类型就像穿上了变色的衣服